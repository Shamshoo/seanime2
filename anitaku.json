{
    "id": "anitaku-provider",
    "name": "AniTaku Provider",
    "description": "Online streaming provider for AniTaku (formerly GoGoAnime)",
    "manifestURI": "https://raw.githubusercontent.com/Shamshoo/NitroSniperGo/refs/heads/master/anitaku.json",
    "version": "1.0.0",
    "author": "Your Name",
    "type": "online-streaming-provider",
    "language": "typescript",
    "lang": "en",
    "payload": "/// <reference path=\"./onlinestream-provider.d.ts\" />\n/// <reference path=\"./doc.d.ts\" />\n/// <reference path=\"./crypto.d.ts\" />\n\nclass Provider {\n\n    api = \"https://anitaku.to\"\n    ajaxURL = \"https://ajax.gogocdn.net\"\n    \n    getSettings(): Settings {\n        return {\n            episodeServers: [\"gogocdn\", \"vidstreaming\", \"streamsb\"],\n            supportsDub: true,\n        }\n    }\n\n    async search(opts: SearchOptions): Promise<SearchResult[]> {\n        const request = await fetch(`${this.api}/search.html?keyword=${encodeURIComponent(opts.query)}`)\n        if (!request.ok) {\n            return []\n        }\n        const data = await request.text()\n        const results: SearchResult[] = []\n\n        const $ = LoadDoc(data)\n\n        $(\"ul.items > li\").each((_, el) => {\n            const title = el.find(\"p.name a\").text().trim()\n            const id = el.find(\"div.img a\").attr(\"href\")\n            if (!id) {\n                return\n            }\n\n            results.push({\n                id: id,\n                title: title,\n                url: id,\n                subOrDub: \"sub\",\n            })\n        })\n\n        return results\n    }\n\n    async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n        const episodes: EpisodeDetails[] = []\n\n        const data = await (await fetch(`${this.api}${id}`)).text()\n\n        const $ = LoadDoc(data)\n\n        const epStart = $(\"#episode_page > li\").first().find(\"a\").attr(\"ep_start\")\n        const epEnd = $(\"#episode_page > li\").last().find(\"a\").attr(\"ep_end\")\n        const movieId = $(\"#movie_id\").attr(\"value\")\n        const alias = $(\"#alias_anime\").attr(\"value\")\n\n        const req = await (await fetch(`${this.ajaxURL}/ajax/load-list-episode?ep_start=${epStart}&ep_end=${epEnd}&id=${movieId}&default_ep=${0}&alias=${alias}`)).text()\n\n        const $$ = LoadDoc(req)\n\n        $$(\"#episode_related > li\").each((i, el) => {\n            episodes?.push({\n                id: el.find(\"a\").attr(\"href\")?.trim() ?? \"\",\n                url: el.find(\"a\").attr(\"href\")?.trim() ?? \"\",\n                number: parseFloat(el.find(`div.name`).text().replace(\"EP \", \"\")),\n                title: el.find(`div.name`).text(),\n            })\n        })\n\n        return episodes.reverse()\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise<EpisodeServer> {\n        let server = \"gogocdn\"\n        if (_server !== \"default\") {\n            server = _server\n        }\n\n        const episodeServer: EpisodeServer = {\n            server: server,\n            headers: {},\n            videoSources: [],\n        }\n\n        if (episode.id.startsWith(\"http\")) {\n            const serverURL = episode.id\n            try {\n                const es = await new Extractor(serverURL, episodeServer).extract(server)\n                if (es) {\n                    return es\n                }\n            }\n            catch (e) {\n                console.error(e)\n                return episodeServer\n            }\n            return episodeServer\n        }\n\n        const data = await (await fetch(`${this.api}${episode.id}`)).text()\n\n        const $ = LoadDoc(data)\n\n        let serverURL: string\n\n        switch (server) {\n            case \"gogocdn\":\n                serverURL = `${$(\"#load_anime > div > div > iframe\").attr(\"src\")}`\n                break\n            case \"vidstreaming\":\n                serverURL = `${$(\"div.anime_video_body > div.anime_muti_link > ul > li.vidcdn > a\").attr(\"data-video\")}`\n                break\n            case \"streamsb\":\n                serverURL = $(\"div.anime_video_body > div.anime_muti_link > ul > li.streamsb > a\").attr(\"data-video\")!\n                break\n            default:\n                serverURL = `${$(\"#load_anime > div > div > iframe\").attr(\"src\")}`\n                break\n        }\n\n        episode.id = serverURL\n        return await this.findEpisodeServer(episode, server)\n    }\n\n}\n\n\nclass Extractor {\n    private url: string\n    private result: EpisodeServer\n\n    constructor(url: string, result: EpisodeServer) {\n        this.url = url\n        this.result = result\n    }\n\n    async extract(server: string): Promise<EpisodeServer | undefined> {\n        try {\n            switch (server) {\n                case \"gogocdn\":\n                    console.log(\"GogoCDN extraction\")\n                    return await this.extractGogoCDN(this.url, this.result)\n                case \"vidstreaming\":\n                    return await this.extractGogoCDN(this.url, this.result)\n                default:\n                    return undefined\n            }\n        }\n        catch (e) {\n            console.error(e)\n            return undefined\n        }\n    }\n\n\n    public async extractGogoCDN(url: string, result: EpisodeServer): Promise<EpisodeServer> {\n        const keys = {\n            key: CryptoJS.enc.Utf8.parse(\"37911490979715163134003223491201\"),\n            secondKey: CryptoJS.enc.Utf8.parse(\"54674138327930866480207815084989\"),\n            iv: CryptoJS.enc.Utf8.parse(\"3134003223491201\"),\n        }\n\n        function generateEncryptedAjaxParams(id: string) {\n            const encryptedKey = CryptoJS.AES.encrypt(id, keys.key, {\n                iv: keys.iv,\n            })\n\n            const scriptValue = $(\"script[data-name='episode']\").data(\"value\")!\n\n            const decryptedToken = CryptoJS.AES.decrypt(scriptValue, keys.key, {\n                iv: keys.iv,\n            }).toString(CryptoJS.enc.Utf8)\n\n            return `id=${encryptedKey.toString(CryptoJS.enc.Base64)}&alias=${id}&${decryptedToken}`\n        }\n\n        function decryptAjaxData(encryptedData: string) {\n\n            const decryptedData = CryptoJS.AES.decrypt(encryptedData, keys.secondKey, {\n                iv: keys.iv,\n            }).toString(CryptoJS.enc.Utf8)\n\n            return JSON.parse(decryptedData)\n        }\n\n        const req = await fetch(url)\n\n        const $ = LoadDoc(await req.text())\n\n        const encryptedParams = generateEncryptedAjaxParams(new URL(url).searchParams.get(\"id\") ?? \"\")\n\n        const xmlHttpUrl = `${new URL(url).protocol}//${new URL(url).hostname}/encrypt-ajax.php?${encryptedParams}`\n\n        const encryptedData = await fetch(xmlHttpUrl, {\n            headers: {\n                \"X-Requested-With\": \"XMLHttpRequest\",\n            },\n        })\n\n\n        const decryptedData = await decryptAjaxData(((await encryptedData.json()) as { data: any })?.data)\n        if (!decryptedData.source) throw new Error(\"No source found. Try a different server.\")\n\n        if (decryptedData.source[0].file.includes(\".m3u8\")) {\n            const resResult = await fetch(decryptedData.source[0].file.toString())\n            const resolutions = (await resResult.text()).match(/(RESOLUTION=)(.*)(\s*?)(\s*.*)/g)\n\n            resolutions?.forEach((res: string) => {\n                const index = decryptedData.source[0].file.lastIndexOf(\"/\")\n                const quality = res.split(\"\\n\")[0].split(\"x\")[1].split(\",\")[0]\n                const url = decryptedData.source[0].file.slice(0, index)\n\n                result.videoSources.push({\n                    url: url + \"/\" + res.split(\"\\n\")[1],\n                    quality: quality + \"p\",\n                    subtitles: [],\n                    type: \"m3u8\",\n                })\n            })\n\n            decryptedData.source.forEach((source: any) => {\n                result.videoSources.push({\n                    url: source.file,\n                    quality: \"default\",\n                    subtitles: [],\n                    type: \"m3u8\",\n                })\n            })\n        } else {\n            decryptedData.source.forEach((source: any) => {\n                result.videoSources.push({\n                    url: source.file,\n                    quality: source.label.split(\" \")[0] + \"p\",\n                    subtitles: [],\n                    type: \"m3u8\",\n                })\n            })\n\n            decryptedData.source_bk.forEach((source: any) => {\n                result.videoSources.push({\n                    url: source.file,\n                    quality: \"backup\",\n                    subtitles: [],\n                    type: \"m3u8\",\n                })\n            })\n        }\n\n        return result\n    }\n}"
}
